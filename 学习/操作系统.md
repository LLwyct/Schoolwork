## 3.1内存管理
### 1.分区方式：
+ 连续分配管理方式
  + 单一连续分配：系统区+用户区，且用户区只放一个进程
  + 固定分区：又分为分区大小相等和分区大小不等
  + 动态分区：需要是不是进行“紧凑”，就是合并空闲的外碎片，有4中策略：1.首次适应2.最佳适应3.最坏适应4.临近适应（从上次结束的地方继续查找）
+ 非连续分配管理方式：
  + 1.页式
  + 2.段式
  + 3.段页式

### 2.程序进入内存需要如下三个步骤：
+ 编译
+ 链接
+ 装入
  + 静态装入（绝对装入）是在编译阶段就算好物理地址
  + 可重定位装入（静态重定位）是在装入阶段算好物理地址
  + 动态运行时装入（动态重定位）是在执行阶段才算物理地址

### 3.覆盖与交换
覆盖与交换是在多道程序环境下用来扩充内存的方法，交换主要是在不同进程之间，覆盖则用于同一进程中。

### 4.分段为什么不会产生内碎片？
首先明确一点，内部碎片是什么？
内部碎片就是为每个进程分布的内存空间之中所没有被使用到的内存碎片。通常出现在分页式存储管理之中。分页式是什么应该很好理解，就是把内存按照分为一页页大小相同的页面，然后再把这些页面分配给进程。因此，在分配给进程时可能会出现这样的情况：进程需要3MB，分给他4页，每页1MB，这样4>3，就会造成1MB的内部碎片。
而分段式存储管理为什么不会产生内部碎片？归根结底是由分段本身的定义出发的。如果说分页式是系统对内存的分割，那么分段式就是用户对程序数据的分割。分页式是没有任何逻辑意义的，而分段式是有其意义在的。比如说一个程序有主程序段Main类，有通用库，有数据段，这样我们就把这个程序分为三段，分别对应Main，库，数据（说的是最浅显的，详细的可以百度其他），是有逻辑意义的独立单位。都这样分了，怎么还会出现内部碎片？反之，如果是分页式，就可能出现Main类横跨两页，且整个程序装入内存后还有碎片空间的可能了。
总之，引入分段式存储管理本就在一定程度上解决了内部碎片，并且满足了用户的需求。但是分段式存储管理也有不足之处，内存利用率变低了。因此又引入之后的段页式存储管理方式，这个自己百度就行。

## 3.2虚拟内存管理
### 1.局部性原理
+ 时间局部性：某条指令一旦执行，不久以后可能会再次执行，数据同理。因为程序中有大量的循环。
+ 空间局部性：一旦程序访问了某个存储单元，那么其附近的存储单元也将被访问。
### 2.虚拟存储器的定义、特征、实现
+ 定义：基于局部性原理，在程序装入时，将一部分装入，其余部分留在内存外，当访问的信息不再内存时，再申请调入。这样，系统好像提供了一个比实际内存更大的存储器，称为虚拟存储器。
+ 特征：
  + 多次性：作业无需一次装入M，而是可以分为多次装入。
  + 对换性：作业无需常驻M，允许换进换出。
  + 虚拟性：从逻辑上扩充内存。
+ 实现：它的实现需要非连续分配的内存管理方式。
  + 请求分页存储管理
  + 请求分段存储管理
  + 请求段页式存储管理

