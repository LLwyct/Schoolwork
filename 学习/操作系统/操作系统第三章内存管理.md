## 3.1内存管理
### 1.分区方式：
+ 连续分配管理方式
  + 单一连续分配：系统区+用户区，且用户区只放一个进程
  + 固定分区：又分为分区大小相等和分区大小不等
  + 动态分区：需要是不是进行“紧凑”，就是合并空闲的外碎片，有4种策略：1.首次适应2.最佳适应3.最坏适应4.临近适应（从上次结束的地方继续查找）
+ 非连续分配管理方式：
  + 1.页式
  + 2.段式
  + 3.段页式

### 2.程序进入内存需要如下三个步骤：
+ 编译
+ 链接
+ 装入
  + 静态装入（绝对装入）是在编译阶段就算好物理地址
  + 可重定位装入（静态重定位）是在装入阶段算好物理地址
  + 动态运行时装入（动态重定位）是在执行阶段才算物理地址

### 3.覆盖与交换
覆盖与交换是在多道程序环境下用来扩充内存的方法，交换主要是在不同进程之间，覆盖则用于同一进程中。

### 4.分段为什么不会产生内碎片？
首先明确一点，内部碎片是什么？
内部碎片就是为每个进程分布的内存空间之中所没有被使用到的内存碎片。通常出现在分页式存储管理之中。分页式是什么应该很好理解，就是把内存按照分为一页页大小相同的页面，然后再把这些页面分配给进程。因此，在分配给进程时可能会出现这样的情况：进程需要3MB，分给他4页，每页1MB，这样4>3，就会造成1MB的内部碎片。
而分段式存储管理为什么不会产生内部碎片？归根结底是由分段本身的定义出发的。如果说分页式是系统对内存的分割，那么分段式就是用户对程序数据的分割。分页式是没有任何逻辑意义的，而分段式是有其意义在的。比如说一个程序有主程序段Main类，有通用库，有数据段，这样我们就把这个程序分为三段，分别对应Main，库，数据（说的是最浅显的，详细的可以百度其他），是有逻辑意义的独立单位。都这样分了，怎么还会出现内部碎片？反之，如果是分页式，就可能出现Main类横跨两页，且整个程序装入内存后还有碎片空间的可能了。
总之，引入分段式存储管理本就在一定程度上解决了内部碎片，并且满足了用户的需求。但是分段式存储管理也有不足之处，内存利用率变低了。因此又引入之后的段页式存储管理方式，这个自己百度就行。

## 3.2虚拟内存管理
### 1.局部性原理
+ 时间局部性：某条指令一旦执行，不久以后可能会再次执行，数据同理。因为程序中有大量的循环。
+ 空间局部性：一旦程序访问了某个存储单元，那么其附近的存储单元也将被访问。
### 2.虚拟存储器的定义、特征、实现
+ 定义：基于局部性原理，在程序装入时，将一部分装入，其余部分留在内存外，当访问的信息不再内存时，再申请调入。这样，系统好像提供了一个比实际内存更大的存储器，称为虚拟存储器。
+ 特征：
  + 多次性：作业无需一次装入M，而是可以分为多次装入。
  + 对换性：作业无需常驻M，允许换进换出。
  + 虚拟性：从逻辑上扩充内存。
+ 实现：它的实现需要非连续分配的内存管理方式。
  + 请求分页存储管理
  + 请求分段存储管理
  + 请求段页式存储管理
  + 硬件支持：1.一定容量的内外存2.页表机制3.中断机构（产生中断）4.地址变换机构（逻辑地址映射到物理地址）
### 3.页面置换算法
+ OPT最佳置换（最长时间内不再被访问）
+ FIFO先进先出
+ LRU最近最少使用（nice）
+ CLOCK时钟
### 4.页面分配策略
#### 4.1驻留集大小：给特定进程分配多少主存空间
太大，由于局部性原理，对减少缺页率没有什么影响。太小，缺页率很高。
+ 固定分配局部置换（给进程分配固定数目的物理块，且不变。弊端：太傻）
+ 可变分配全局置换（先分配一定数目的物理块，如果缺页，则从空闲物理块中分配给进程。弊端：无脑分配，降低并发能力）
+ 可变分配局部置换（当频繁缺页时分配物理块，当缺页率低时减少物理块。弊端：难度大）
#### 4.2调入页面的时机（一般两者会配合使用）
+ 预调页策略（一次调一批，但只用于运行前的第一次调入）
+ 请求调页策略（一次调一页，用于运行中）
#### 4.3从何处调
外存分为文件区（离散存储）、对换区（连续存储），因此对换区效率高。
### 5.抖动
刚换出的页面又要立马换入，总之，就是过于频繁的缺页
### 6.驻留集（工作集）